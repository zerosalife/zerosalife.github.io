<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | zero's a life]]></title>
  <link href="http://zerosalife.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://zerosalife.github.io/"/>
  <updated>2015-05-30T11:49:29-05:00</updated>
  <id>http://zerosalife.github.io/</id>
  <author>
    <name><![CDATA[zerosalife]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Syntax highlighting for Octopress]]></title>
    <link href="http://zerosalife.github.io/blog/2015/01/17/syntax-highlighting-for-octopress/"/>
    <updated>2015-01-17T11:12:37-06:00</updated>
    <id>http://zerosalife.github.io/blog/2015/01/17/syntax-highlighting-for-octopress</id>
    <content type="html"><![CDATA[<p>It&rsquo;s relatively simple, but I always forget how it&rsquo;s done.  In the
interest of documenting useful information for myself, here is how to
use <a href="http://octopress.org/docs/blogging/code/">syntax highlighting with code blocks in Octopress</a>.</p>

<!--more-->


<p>Here are some examples of languages I typically use:</p>

<p>``` csharp
private IEnumerator GUIMoveToPosition(Vector3 newPosition, float duration, RectTransform rect) {
  float elapsedTime = 0;
  Vector3 startingPos = rect.position;
  while(elapsedTime &lt; duration) {</p>

<pre><code>rect.position = Vector3.Lerp(startingPos,
                             newPosition,
                             elapsedTime / duration);
elapsedTime += Time.deltaTime;
yield return null;
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>``` python
def update(self, time_elapsed):</p>

<pre><code>self.tick += 1
self.total_time += time_elapsed

if self.mode:
    self.mode.update(time_elapsed)
</code></pre>

<p>```</p>

<p>``` clojure
(defn valid-string? [s]
  &ldquo;Valid strings are non-empty strings that do not contain
  [ (commonly used to denote parts of the song and which rappers are
  rapping) and : (commonly used in the album info and transcriber
  info).&rdquo;
  (and (not (contains-char? s [))</p>

<pre><code>   (not (contains-char? s \:))
   (not (contains-char? s \"))
   (not (contains-char? s \())
   (seq s)))
</code></pre>

<p>;;; <a href="http://clojuredocs.org/clojure_core/clojure.core/empty_q">http://clojuredocs.org/clojure_core/clojure.core/empty_q</a>
;;; Please use the idiom (seq x) rather than (not (empty? x))
```</p>

<h2>Bonus: Help me refactor this code</h2>

<p>I think there&rsquo;s some way to refactor these two similar functions so
they don&rsquo;t share code, but I don&rsquo;t see it.  If you have a clever way
to offload the common functionality, let me know in the comments
(<a href="http://gist.github.com">gists</a> preferred).</p>

<p>``` csharp
// NOTE: there are some differences between the two functions
// because I&rsquo;m still adding funcitonality.  I think there should be
// a way to pull out some of the common functionality so I don&rsquo;t
// have two functions that share code.  Maybe by separating the
// boundary checks from the actual &ldquo;counting&rdquo; steps?</p>

<p>void Countdown () {
  int iTargetHp = iHp + 1;</p>

<p>  // If the rolling hp reaches the hit point above iHp then we can
  // stop the rolling because each RollEvent effectively moves past
  // the current iRolHp.
  if(iRolHp == iTargetHp) {</p>

<pre><code>// Start Coroutine to return reels to original positions
StartCoroutine(WaitAndResetReels(RollDir.Down));

CancelInvoke("Countdown");
</code></pre>

<p>  }
  if(iRolHp &lt;= 0) {</p>

<pre><code>StartCoroutine(WaitAndResetReels(RollDir.Down));

// TRUE DEATH!
CancelInvoke("Countdown");
</code></pre>

<p>  }
  // If the rolling HP is larger than the target HP and positive,
  // then roll down.
  if(iRolHp > iTargetHp || iRolHp > 0) {</p>

<pre><code>RollEvent(RollDir.Down);
</code></pre>

<p>  }</p>

<p>  iRolHp = iRolHp + (int)RollDir.Down;</p>

<p>}</p>

<p>void Countup() {
  int iTargetHp = iHp &ndash; 1;</p>

<p>  // If the rolling hp reaches the hit point below iHp then we can
  // stop rolling because each RollEvent effectively moves past the
  // current iRolHp.
  //
  // Also take care of some nasty edge cases resulting in two calls
  // to WaitAndResetReels.
  if(iRolHp == iTargetHp &amp; iRolHp &lt; iMaxHp &amp; iRolHp != iMaxHp) {</p>

<pre><code>StartCoroutine(WaitAndResetReels(RollDir.Up));

CancelInvoke("Countup");
</code></pre>

<p>  } else if(iRolHp >= iMaxHp) {</p>

<pre><code>iHp = iMaxHp;
StartCoroutine(WaitAndResetReels(RollDir.Up));

// Maxed out HP.
CancelInvoke("Countup");
</code></pre>

<p>  }</p>

<p>  // If the rolling HP is smaller than the target HP and less than
  // Max HP, then roll up.
  if(iRolHp &lt; iTargetHp || iRolHp &lt; iMaxHp) {</p>

<pre><code>RollEvent(RollDir.Up);
</code></pre>

<p>  }</p>

<p>  iRolHp = iRolHp + (int)RollDir.Up;</p>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Mind-reading Machine in Unity JavaScript]]></title>
    <link href="http://zerosalife.github.io/blog/2014/12/13/simple-mind-reading-machine-in-unity-javascript/"/>
    <updated>2014-12-13T14:38:20-06:00</updated>
    <id>http://zerosalife.github.io/blog/2014/12/13/simple-mind-reading-machine-in-unity-javascript</id>
    <content type="html"><![CDATA[<p>I ported a cool toy from <a href="http://alastaira.wordpress.com/2014/03/15/a-simple-mind-reading-machine/">Alastair Aitchison&rsquo;s blog</a> to Unity JavaScript.  The toy implements a simple &lsquo;mind-reading&rsquo; algorithm that attempts to guess whether the player will choose Left (by pressing the left arrow key) or Right (by pressing the right arrow key).</p>

<!--more-->


<h2>How does it work?</h2>

<p>Aitchison&rsquo;s blog post describes how it works:</p>

<blockquote><p>How does it work? Not by mind-reading, obviously, but by exploiting
the fact that humans do not behave as &ldquo;randomly&rdquo; as they think they
do. The computer maintains a very simple memory that records the
pattern of results of the last two rounds â€“ whether the player won or
lost, whether they switched strategy, and then whether they then won
or last the following round. The computer then uses this to choose its
own best strategy based on the way the player behaved last time the
current pattern occurred. If the computer loses twice in a row using
the current strategy, it picks a random response in the next round.</p></blockquote>

<p>The original idea came from some AI work by <a href="http://en.wikipedia.org/wiki/Claude_Shannon">Claude Shannon</a> and D. W. Hagelbarger. <a href="http://cs.stanford.edu/people/eroberts/courses/soco/projects/1999-00/information-theory/ai.html">They describe the internal memory of the toy mind-reader</a> that we will model using a multidimensional array <code>v</code>:</p>

<blockquote><p>There are 8 possible situations and two things the player can do at each one:</p>

<ol>
<li><p>player wins, plays same, wins. Then same or differently.</p></li>
<li><p>player wins, plays same, loses. Then same or differently.</p></li>
<li><p>player wins, plays differently, wins. Then same or differently.</p></li>
<li><p>player wins, plays differently, loses.Then same or differently.</p></li>
<li><p>player loses, plays same, wins.Then same or differently.</p></li>
<li><p>player loses, plays same, loses.Then same or differently.</p></li>
<li><p>player loses, plays differently, wins.Then same or differently.</p></li>
<li><p>player loses, plays differently, loses.Then same or differently.</p></li>
</ol>
</blockquote>

<h2>Why port it?</h2>

<p>Why not just take a straightforward approach, running the code myself? First, I wanted to fully understand the algorithm the hard way, by coding it line for line myself. And second, I wanted to better familiarize myself with Unity JavaScript, including its differences from C#.</p>

<p>The port was relatively simple, except for two small hiccups.  First, as far as I know, Unity JavaScript doesn&rsquo;t allow for initializing a multidimensional array.  So I looped over the cells in the array, filling them that way.  I have a hunch that the cells are initialized to the <code>int</code> <code>0</code> by default, but I wanted to be explicit.  Please let me know in the comments or <a href="https://twitter.com/zerosalife">via twitter</a> if I&rsquo;m way off base.</p>

<pre><code>var v : int[2, 2, 2];
for(var cell in v) {
    cell = 0;
}
</code></pre>

<p>I also encountered some unfamiliar syntax: the sonorously named Elvis operator, <a href="http://en.wikipedia.org/wiki/Conditional_operator">?:</a>.  It&rsquo;s also called the <a href="http://en.wikipedia.org/wiki/Ternary_operation">ternary operator</a>, when it&rsquo;s used with 3 arguments, as I&rsquo;ve used it here.  In C-like languages it allows for succinctly stating these kinds of conditional expressions. The example below illustrates how it&rsquo;s used.</p>

<pre><code>// Is the current player's choice the same as the previous player's
// choice?
//
// if (playerChoice == lastChoice)
//     sameChoice = True;
// else
//     sameChoice = False;
//
// Using ternary operator:
v[lw2, lw1, 1] = (v[lw2, lw1, 0] == playerChoice ? 1 : 0);
</code></pre>

<h2>The code</h2>

<p>The ported code for the mind-reader is reproduced below.</p>

<pre><code>#pragma strict
import System.Collections.Generic;

// Used to record play history
var v: int[,,];
var lw1: int;
var lw2: int;
var losingStreak: int;

// The prediction of the player's next turn
var prediction: int;

// Keep track of scores
var cpuScore: int;
var playerScore: int;

var outText: String;

function Start () {
    // Initialize matrix to track state of play history

    v = new int[2, 2, 2];

    for(var cell in v) {
        cell = 0;
    }

    // No prior knowledge, so set inital prediction based on random chance.
    prediction = flip();

    // Set scores to 0
    cpuScore = 0;
    playerScore = 0;

    // Initialize previous play and play before last win-lost trackers
    lw1 = 0;
    lw2 = 0;

    // Output
    outText = "";
}

function TakeTurn(playerChoice: int) {
    // Display player and computer's choices
    var outTextString: String = "You pressed " + playerChoice + ", " + "I guessed " + prediction + "\n";

    // Computer guessed correctly
    if (playerChoice == prediction) {
        cpuScore++;
        losingStreak = 0;
        outTextString += " I WIN!\n";
    }
    else {
        playerScore++;
        losingStreak++;
        outTextString += " YOU WIN!\n";
    }

    outText = outTextString;

    // Is the current player's choice the same as the previous player's
    // choice?
    //
    // if (playerChoice == lastChoice)
    //     sameChoice = True;
    // else
    //     sameChoice = False;
    //
    // Using ternary operator:
    v[lw2, lw1, 1] = (v[lw2, lw1, 0] == playerChoice ? 1 : 0);
    v[lw2, lw1, 0] = playerChoice;
    lw2 = lw1;
    lw1 = playerChoice;

    // If lost more than twice in present state, choose random
    // strategy.  Otherwise keep the same strategy.
    prediction = v[lw2, lw1, 1] == 1 &amp;&amp; losingStreak &lt; 2 ? v[lw2, lw1, 0] : flip();
}

function flip() : int {
    // Simulate a coin flip to produce 50:50 chance of [0, 1]
    return Random.Range(0, 2);
}


function Update () {
    if (Input.GetKeyDown(KeyCode.LeftArrow)) {
        TakeTurn(0);
    }
    if (Input.GetKeyDown(KeyCode.RightArrow)) {
        TakeTurn(1);
    }
}

function OnGUI() {
    var style : GUIStyle = new GUIStyle();
    style.fontSize = 36;

    GUI.Label(new Rect(0, 0, Screen.width, 100), outText, style);
    GUI.Label(new Rect(0, 100, Screen.width, 200), "Player: " + playerScore + " CPU: " + cpuScore, style);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hammock Driven Creativity]]></title>
    <link href="http://zerosalife.github.io/blog/2014/05/31/hammock-driven-creativity/"/>
    <updated>2014-05-31T11:28:40-05:00</updated>
    <id>http://zerosalife.github.io/blog/2014/05/31/hammock-driven-creativity</id>
    <content type="html"><![CDATA[<p>In 2010, <a href="https://twitter.com/richhickey">Rich Hickey</a> spoke at Clojure Conj about <a href="http://www.youtube.com/watch?v%3Df84n5oFoZBc">&lsquo;Hammock Driven Development&rsquo;</a>.  Hickey was talking about the benefit of down-time for noodling about software design.  Specifically, Hickey means using down-time after considerably &lsquo;loading up&rsquo; your mind with aspects of the problem, in order to leverage background offline processes to solve those difficult problems.</p>

<!--more-->


<h2>Wait</h2>

<p>Hickey&rsquo;s advice is to wait for it.  Wait overnight.  Get good rest and make sure that you are sleeping well.  Then you will be able to think about the clearly on the next day.  If you are lucky perhaps you will receive inspiration from a dream and wake up with the problem solved.  This sort of inspiration is what Hickey means by leveraging background processing.</p>

<h2>Multiply</h2>

<p>Hickey mentions working on more than one project.  By having multiple projects, you avoid the problems of creative block, or writer&rsquo;s block.  You can be productive simply by working on another project.  One drawback is that frantically flitting from project to project can lead to problems finishing any single project.  I am often guilty of this.</p>

<p>Eventually, I plan on writing about properly scoping projects to make it possible to get them to a finished state.  One method that works for me is getting something to the point that I can write a blog post about it.  Even if it&rsquo;s not &lsquo;finished&rsquo; finished, I get some satisfaction with putting it out there in a relatively well thought out and complete form.</p>

<p>My solution is to <strong>record, record, record</strong>.  I keep lots of notes, both in more structured form on this blog and in more sketchy form in files on my computer.  I also draw out visual design ideas in a notebook.  Sometimes I will set up skeleton game projects simply to test out an idea.  If I have some sudden insight into a problem, then all of these ideas are available later.</p>

<h2>Switch</h2>

<p>Hickey says to avoid being stuck, switch.  That is why having multiple projects can help.  Hickey also mentions a great suggestion of talking about design hiccups and problems with other people.  Tweet about your design roadblocks.  Write a blog post about them.  Telepathically communicate about them before you go to sleep, so magical dream elves can come and solve them for you.</p>

<h2>Final Thoughts</h2>

<blockquote><p>Summary: There is no summary.  This is a rant.</p></blockquote>

<p>-Rich Hickey</p>

<p>Unless you are Rich Hickey or&#x2013;I dunno&#x2013;Gary Gygax, simply thinking about a problem <em>a priori</em> will not result in a great game.  There is still something to be said for getting your hands dirty and iterating on a design.  However the techniques highlighted in Hickey&rsquo;s talk can be useful when you are stuck on a design problem.</p>

<p>Hit me up in the comments or on the <a href="https://twitter.com/zerosalife">tweet tweet</a> if you have any great Hammock Driven Design tips that I haven&rsquo;t covered here.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Rhizome Labeled Edge Tutorial]]></title>
    <link href="http://zerosalife.github.io/blog/2014/04/26/clojure-rhizome-labeled-edge-tutorial/"/>
    <updated>2014-04-26T09:47:18-05:00</updated>
    <id>http://zerosalife.github.io/blog/2014/04/26/clojure-rhizome-labeled-edge-tutorial</id>
    <content type="html"><![CDATA[<p>I&rsquo;m using the <a href="https://github.com/ztellman/rhizome">Rhizome package</a> for Clojure to rapidly prototype the dependency graph for a crafting system.  It&rsquo;s nice to be able to add and remove components while generating visualizations on-the-fly.  Clojure&rsquo;s simple, composable syntax, aided by <a href="https://www.youtube.com/watch?v=D6h5dFyyUX0">paredit</a>, makes shuffling around key-value pairs, and even whole dictionaries, quick and easy.</p>

<p>The existing Rhizome documentation shows simple examples for labeling the nodes of a directed graph.  In order to show the relationship between nodes on the graph, I&rsquo;d like to also label the edges, or the arrows connecting the nodes.</p>

<p>Rhizome provides a keyword argument <code>:edge-&gt;descriptor</code> to most of its functions.  Consulting the source code and the tests for the Rhizome package, I learned that the functions expect <code>:edge-&gt;descriptor</code> to be a function accepting two arguments for each edge: <code>src</code>, the source node, and <code>dst</code>, the destination node.  In order to label the edges, the anonymous function I&rsquo;m binding to <code>:edge-&gt;descriptor</code> will return a dictionary containing the key <code>:label</code> and the value for the edge&rsquo;s label.</p>

<p>Here&rsquo;s an example using the simple graph from the Rhizome documentation:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="nf">use</span> <span class="o">&amp;</span><span class="nv">lsquo</span><span class="c1">;rhizome.viz)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">def </span><span class="nv">g&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">{</span><span class="ss">:a</span> <span class="p">[</span><span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span>
</span><span class='line'> <span class="ss">:b</span> <span class="p">[</span><span class="ss">:c</span><span class="p">]</span>
</span><span class='line'> <span class="ss">:c</span> <span class="p">[</span><span class="ss">:a</span><span class="p">]})</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">view-graph</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">g</span><span class="p">)</span> <span class="nv">g&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span>        <span class="ss">:node-</span><span class="o">&amp;</span><span class="nv">gt</span><span class="c1">;descriptor (fn [n] {:label n}))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><img src="/images/assets/graph-unlabeled-edges.png"></p>

<p>Now, I&rsquo;ll use a dictionary of dictionaries to associate the source and destination nodes with a label for each edge.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">g-edges</span>
</span><span class='line'>  <span class="p">{</span><span class="ss">:a</span> <span class="p">{</span><span class="ss">:b</span> <span class="ss">:makes&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span>   <span class="ss">:c</span> <span class="ss">:takes</span><span class="p">}</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>   <span class="ss">:b</span> <span class="p">{</span><span class="ss">:c</span> <span class="ss">:takes</span><span class="p">}</span>
</span><span class='line'>   <span class="ss">:c</span> <span class="p">{</span><span class="ss">:a</span> <span class="ss">:makes</span><span class="p">}})</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">view-graph</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">g</span><span class="p">)</span> <span class="nv">g&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span>        <span class="ss">:node-</span><span class="o">&amp;</span><span class="nv">gt</span><span class="c1">;descriptor (fn [n] {:label n})</span>
</span><span class='line'>        <span class="ss">:edge-</span><span class="o">&amp;</span><span class="nv">gt</span><span class="c1">;descriptor (fn [src dst] {:label (dst (src g-edges))}))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><img src="/images/assets/graph-labeled-edges.png"></p>

<p>I&rsquo;ve submitted a <a href="https://github.com/ztellman/rhizome/pull/8">pull request</a> to Rhizome to add this example to the documentation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cut it all right in two: bisect to find bugs]]></title>
    <link href="http://zerosalife.github.io/blog/2014/03/08/cut-it-all-right-in-two-bisect-to-find-bugs/"/>
    <updated>2014-03-08T10:25:02-06:00</updated>
    <id>http://zerosalife.github.io/blog/2014/03/08/cut-it-all-right-in-two-bisect-to-find-bugs</id>
    <content type="html"><![CDATA[<p>Imagine there&rsquo;s a lion in a desert.  You need to cage the lion or you
will be eaten.  In this example the desert is your code and the lion
is a bug that you&rsquo;re having a hard time pinning down.</p>

<p>There are many ways to trap a lion.  Here&rsquo;s one.</p>

<p>Build a fence dividing the desert in half going North to South.
Assuming the lion is not in the South section, divide the North
section in half with a fence going East to West.  Repeat the process
until your fence is arbitrarily small and has become a cage trapping
the lion.</p>

<p>But how does this relate to code?</p>

<p>Say you have a relatively large file that executes fine, but
introduces a bug into your larger system.  You suspect that something
has gone wrong with the large file, but you&rsquo;re not getting an error
implicating a specific line.</p>

<p>Cut it all right in two.</p>

<p>Comment out half the code in your large file and try to reproduce the
bug.  If you reproduce the bug, repeat the process as necessary until
you isolate the line producing the problem.</p>

<p>I learned about this approach for bugsleuthing from the <a href="https://gist.github.com/stardiviner/8109774#file-temp-txt-L26">bot in #emacs on freenode</a>.  It&rsquo;s particularly useful for tracking down bugs in large configuration files.  There&rsquo;s a list of humorous lion-trapping algorithm examples <a href="http://faculty.smu.edu/yzhou/humor/lion.htm">here</a>.</p>
]]></content>
  </entry>
  
</feed>
